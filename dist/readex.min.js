const e = {
  dotAll: [!1, "s"],
  global: [!0, "g"],
  ignoreCase: [!1, "i"],
  multiline: [!0, "m"],
  sticky: [!1, "y"],
  unicode: [!1, "u"]
}, g = (n) => {
  if (!(n instanceof Object))
    throw new TypeError("Flags must be an object.");
  return Object.keys({ ...e, ...n }).reduce((r, o) => {
    if (!(o in e)) throw new TypeError("Invalid flag key.");
    return n[o] ?? e[o][0] ? r + e[o][1] : r;
  }, "");
}, d = (n) => {
  if (n instanceof RegExp) return n.source;
  if (["string", "number"].includes(typeof n))
    return new RegExp(`${n}`.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&")).source;
  throw new TypeError("Expression must be a string or number");
}, t = (n = "", r = "", o = "", i = (s) => s, y = {}) => (...s) => new RegExp(
  `${n}${s.map((h) => d(i(h))).join(o)}${r}`,
  g(y)
), a = (n) => Array.isArray(n) && n.length === 2 ? t("", "", "-")(...n) : t()(n), m = (n, r) => t("", "", "", (o) => o, r)(...n), b = (n) => {
  if (typeof n == "string")
    return t(`\\k<${n}`, ">")();
  if (typeof n == "number") return t(`\\${n}`)();
  throw new TypeError("Reference must be a number or a string.");
}, l = t("(", ")"), p = t("(?:", ")"), w = ({ name: n }, ...r) => {
  if (!n || typeof n != "string")
    throw new TypeError("Named groups must have a name.");
  return t(`(?<${n}>`, ")")(...r);
}, f = p, $ = t("(?:", ")", "|"), O = t("(?=(?:", "))"), E = t("(?!(?:", "))"), k = t("(?<=(?:", "))"), L = t("(?<!(?:", "))"), c = (n) => n === null || Number.isInteger(n) && n >= 0, u = (n) => {
  const [r = 0, o = null] = Array.isArray(n) ? n : [n, n];
  if (o !== null && r > o || !c(r) || !c(o))
    throw new TypeError("Times must be a number or 2-number array.");
  return r === o ? `{${r}}` : `{${r},${o ?? ""}}`;
}, z = t("(?:", ")?"), C = t("(?:", ")??"), T = t("(?:", ")+"), S = t("(?:", ")+?"), A = t("(?:", ")*"), R = t("(?:", ")*?"), j = ({ times: n }, ...r) => t("(?:", `)${u(n)}`)(...r), B = ({ times: n }, ...r) => t("(?:", `)${u(n)}?`)(...r), F = /^/, G = /$/, M = /\b/, W = /\B/, v = /\d/, x = /\D/, D = /\w/, I = /\W/, N = /\s/, V = /\S/, q = /./, H = /.*/, J = /.+/, K = t("[", "]", "|", a), P = t("[^", "]", "|", a);
export {
  q as anyCharacter,
  H as anything,
  P as anythingBut,
  K as anythingFrom,
  b as backReference,
  l as captureGroup,
  f as concat,
  v as digit,
  G as endOfLine,
  O as lookahead,
  k as lookbehind,
  w as namedGroup,
  E as negativeLookahead,
  L as negativeLookbehind,
  p as nonCaptureGroup,
  x as nonDigit,
  V as nonWhitespaceCharacter,
  W as nonWordBoundary,
  I as nonWordCharacter,
  T as oneOrMore,
  S as oneOrMoreLazy,
  $ as or,
  m as readEx,
  j as repeat,
  B as repeatLazy,
  J as something,
  F as startOfLine,
  N as whitespaceCharacter,
  M as wordBoundary,
  D as wordCharacter,
  A as zeroOrMore,
  R as zeroOrMoreLazy,
  z as zeroOrOne,
  C as zeroOrOneLazy
};
